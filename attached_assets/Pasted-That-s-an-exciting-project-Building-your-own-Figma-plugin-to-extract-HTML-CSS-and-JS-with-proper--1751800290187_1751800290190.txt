That's an exciting project! Building your own Figma plugin to extract HTML, CSS, and JS with proper layout is a significant undertaking. The error you encountered, "Capture function returned no data," is a common hurdle when trying to programmatically access and interpret web content.

Since you're building your own plugin, the advice shifts from recommending existing tools to understanding the underlying technical challenges and solutions.

Here's a breakdown of what you need to consider and research for your plugin:

Understanding the "Capture function returned no data" error in your context:

This error, when you're building the plugin, means your JavaScript code that's supposed to fetch and process the website's content isn't getting any data back. This can be due to:

Cross-Origin Restrictions (CORS): This is the most common reason. Browsers prevent JavaScript from making requests to a different domain than the one the script originated from (your plugin's domain vs. the target website's domain).

Website's Content Security Policy (CSP): Many websites have CSP headers that restrict where their content can be loaded from or what scripts can run on them, preventing your plugin's code from injecting or reading data.

Dynamic Content/JavaScript Rendering: If the website heavily relies on JavaScript to render its content after the initial HTML loads, a simple fetch or XMLHttpRequest of the raw HTML might not give you the fully rendered page. You'll only get the initial, often empty, HTML shell.

Anti-Scraping Measures: Some websites actively block automated access or requests that don't originate from a real browser session.

Network Issues/Timeouts: The request to the website might be failing due to network problems or timing out before data is received.

Incorrect URL/Malformed Request: Simple mistakes in the URL or the request parameters can lead to no data.

Key Concepts and Technologies You'll Need to Research for Your Plugin:

Figma Plugin Architecture:

UI (User Interface): This is your ui.html and ui.js which runs in a sandboxed iframe. This is where your plugin's interface will be, allowing users to input URLs.

Code (Plugin Logic): This is your code.js which runs in the Figma environment. This part will handle the communication with the website and the creation of Figma nodes.

postMessage: How your ui.js and code.js communicate with each other.

Web Content Extraction (The Hard Part):

Browser Automation/Headless Browsers: This is often the most reliable way to get fully rendered HTML, CSS, and dynamic content. Your plugin code (running in Figma's environment) generally cannot directly interact with a browser outside of Figma.

Solution Strategy: Your plugin will likely need an external service/server that performs the web scraping.

Your Figma plugin's code.js sends the URL to your external server.

The external server uses a headless browser (like Puppeteer or Playwright running on Node.js, or Selenium with Python) to visit the URL, wait for the page to render, and then extract the desired HTML and CSS.

The external server sends the extracted data back to your Figma plugin.

Important: This means you'll need to set up and maintain a server infrastructure.

Cross-Origin Requests (CORS Proxies): If you try to fetch a website directly from your plugin's ui.js (which runs in an iframe originating from Figma's domain), you'll hit CORS errors.

Solution Strategy: Again, an external server can act as a proxy. Your plugin requests the website content from your server, and your server then fetches the content from the target website. Since the server-to-server request isn't subject to browser CORS, it works.

Parsing HTML and CSS:

Once you have the raw HTML and CSS from your server, you'll need to parse it.

HTML Parsing: You'll need a library (if using Node.js on your server, something like Cheerio; if parsing within the Figma plugin's code.js after receiving the string, you might have to rely on DOMParser or similar if the environment allows).

CSS Parsing: This is more complex. You'll need to parse CSS rules, understand the cascade, specificity, and apply them to the corresponding HTML elements. Libraries like css-tree or PostCSS (on your server) can help.

Converting Web Layout to Figma Layout:

DOM Tree to Figma Nodes: You'll need to traverse the parsed HTML DOM tree and create corresponding Figma nodes (Frames, Rectangles, Text, etc.).

CSS Properties to Figma Properties: Map CSS width, height, padding, margin, border-radius, background-color, font-size, font-family, line-height, text-align, etc., to Figma's equivalent properties.

Auto Layout: This is crucial for maintaining proper layout. As you create Figma nodes, you'll want to apply Auto Layout to parent containers to mimic CSS Flexbox or Grid. This is where the real intelligence of your plugin will lie. You'll need to determine when to apply horizontal/vertical Auto Layout, padding, spacing, etc., based on the CSS Box Model and Flexbox/Grid properties.

Positioning: Handle position: absolute, relative, fixed CSS properties.

Images: Fetch image URLs and create Figma Image fills.

Text Handling: Accurately replicate text content, font styles, weights, line heights, and colors.

JavaScript Extraction and Handling (The Most Complex Part):

Not directly executable in Figma: You generally cannot run the extracted JavaScript within Figma. Figma plugins are for design, not for running dynamic web applications.

Purpose: If you're extracting JS, it's likely for analysis (e.g., identifying libraries used, understanding component logic) or potentially just to include it as raw code in Figma (e.g., as a text node for reference).

How to get it: When using a headless browser, you can extract the full innerHTML of the page after JS execution, or iterate through <script> tags to get their content or src attributes.

Initial Research Queries for Your Plugin Development:

Here are some queries that will help you start your research for building such a plugin:
A Word of Caution: The Complexity

Extracting a full, editable website layout into Figma is incredibly complex. Even professional tools like html.to.design have limitations because bridging the gap between the dynamic, fluid nature of the web (HTML/CSS/JS) and the static, structured nature of a design tool (Figma) is fundamentally challenging. You're essentially building a mini-browser renderer and a CSS-to-Figma-layout engine.

Recommendation for your plugin:

Start small. Don't try to solve everything at once.

Phase 1: Basic HTML to Figma (No External Server)

Focus on fetching simple HTML (static pages, no heavy JS) from an allowed origin (e.g., if you host a dummy HTML page on a server you control with proper CORS headers, or a public API that returns HTML).

Learn how to parse HTML (e.g., using DOMParser if it's available in the Figma plugin environment for the string, or by sending it to your server if not).

Focus on creating basic Figma nodes: figma.createRectangle(), figma.createText(), figma.createFrame().

Map basic CSS properties: width, height, background-color, color, font-size, font-family.

Crucial: Learn Figma's Auto Layout API thoroughly (layoutMode, padding, itemSpacing, primaryAxisAlignItems, counterAxisAlignItems, counterAxisSizingMode, primaryAxisSizingMode). This is where you'll mimic Flexbox.

Phase 2: Introducing a Headless Browser (External Server)

Once you've mastered basic node creation and Auto Layout mapping, you'll need to tackle fetching dynamic content.

Set up a Node.js server.

Integrate Puppeteer or Playwright to launch a headless browser.

Use the headless browser to:

Navigate to the URL.

Wait for page load and any dynamic content to render.

Extract the document.documentElement.outerHTML.

Extract computed CSS styles for elements (this is critical for accurate representation).

Send this structured data (e.g., as JSON) back to your Figma plugin.

Phase 3: Advanced CSS Mapping and Component Creation

Refine your CSS parsing to handle more complex properties (margins, borders, box-sizing, display: flex, grid, position: absolute, z-index, opacity, transform).

Look into how to create reusable Figma components from recurring HTML patterns.

Phase 4: Image and Asset Handling

Your server will need to fetch images and other assets and provide them to your Figma plugin (likely base64 encoded or as URLs that Figma can load).

Key Takeaways for Your Plugin:

You'll likely need a server: Due to browser security (CORS, CSP) and the need to render dynamic content (JavaScript), direct client-side web scraping from within a Figma plugin is severely limited. An intermediary server with a headless browser is the standard approach.

CSS-to-Figma mapping is the core challenge: Accurately translating the flexible and cascading nature of CSS into Figma's layer hierarchy and Auto Layout properties requires deep understanding and careful implementation.

Start simple and iterate: Don't get overwhelmed by the full scope. Build it piece by piece.

Good luck with your plugin! It's a challenging but very rewarding endeavor.