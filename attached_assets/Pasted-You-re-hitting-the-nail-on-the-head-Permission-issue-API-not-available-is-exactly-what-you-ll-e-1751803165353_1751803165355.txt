You're hitting the nail on the head! "Permission issue (API not available)" is exactly what you'll encounter when trying to access external web content directly from your Figma plugin due to browser security models. Let's break down why this happens and how to overcome it.

Understanding the "API not available" / Permission Issue:

Figma plugins run in a highly secure, sandboxed environment. This is crucial for user security and preventing malicious plugins from accessing your local files or sensitive data.

CORS (Cross-Origin Resource Sharing): This is the primary culprit. When your plugin (which technically runs from Figma's domain, even if it's "localhost" during development) tries to make a fetch or XMLHttpRequest to a different domain (like https://example.com), the browser's security policy kicks in and blocks the request. The target website's server needs to explicitly allow requests from your plugin's origin by setting Access-Control-Allow-Origin headers. Since you don't control the target website, this won't happen.

null Origin Iframes: Figma plugin UIs run in iframes with a null origin. Many servers are configured to block requests from null origins as a security measure, even if CORS is otherwise configured.

No Direct File System/Network Access: Your plugin's code.js (the part that runs in the Figma environment) doesn't have direct access to the wider internet or your local file system beyond what Figma's API explicitly provides.

Browser APIs vs. Figma Plugin APIs: The error "API not available" can also mean you're trying to use a standard browser API (like document.querySelector on an arbitrary URL, or direct fetch to a website) in the code.js context, where it's not present, or in the ui.js context where it's restricted by CORS. The figma object is your primary interface to Figma's capabilities, and figma.ui.postMessage is how you communicate with your UI.

The Solution: An External Server (Your Plugin's Backend)

As discussed previously, the most robust and common solution for web content extraction in Figma plugins is to use an external server. This server acts as an intermediary, bypassing the browser's same-origin policy and providing the necessary environment for web scraping.

Here's how to set it up and what you'll need:

1. Your Figma Plugin (Frontend - ui.html, ui.js, code.js)

ui.html: Your plugin's user interface. It will have an input field for the website URL and a button to initiate the capture.

ui.js:

Listens for button clicks.

Gets the URL from the input.

Sends the URL to code.js using parent.postMessage.

Listens for responses from code.js to update the UI (e.g., show progress, display errors, indicate success).

JavaScript

// ui.js
document.getElementById('captureButton').onclick = () => {
    const url = document.getElementById('websiteUrl').value;
    if (url) {
        parent.postMessage({ pluginMessage: { type: 'captureWebsite', url } }, '*');
    } else {
        // Display an error in the UI
        document.getElementById('status').textContent = 'Please enter a URL.';
    }
};

window.onmessage = (event) => {
    const { type, data, error } = event.data.pluginMessage;
    if (type === 'websiteData') {
        document.getElementById('status').textContent = 'Website captured! Processing in Figma...';
        // You might send this data back to your server for further processing or
        // directly process it in the UI if it's not too heavy, then send to code.js for Figma node creation.
        // For complex processing, it's better to keep it in code.js or on the server.
    } else if (type === 'captureError') {
        document.getElementById('status').textContent = `Error: ${error}`;
    }
};
code.js:

Listens for messages from ui.js.

When it receives a captureWebsite message, it needs to send the URL to your external server.

Listens for responses from your external server.

Once it gets the HTML/CSS data, it uses Figma's API to create nodes.

Sends messages back to ui.js to update the UI (figma.ui.postMessage).

JavaScript

// code.js
figma.ui.onmessage = async (msg) => {
    if (msg.type === 'captureWebsite') {
        const websiteUrl = msg.url;
        try {
            // Send the URL to your external server
            // **THIS IS WHERE THE API CALL TO YOUR SERVER HAPPENS**
            const response = await fetch('YOUR_SERVER_ENDPOINT/capture', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ url: websiteUrl }),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const { html, css, error } = await response.json(); // Your server sends back HTML and CSS

            if (error) {
                figma.ui.postMessage({ type: 'captureError', error });
                return;
            }

            figma.ui.postMessage({ type: 'websiteData', data: { html, css } });

            // Now, use html and css to create Figma nodes
            // (This part is the complex rendering logic mentioned in the previous answer)
            // Example: Create a frame and add some text
            const frame = figma.createFrame();
            frame.resize(100, 100);
            frame.name = 'Captured Website';
            figma.currentPage.appendChild(frame);

            const text = figma.createText();
            text.characters = `Captured HTML: ${html.substring(0, 100)}...`; // Truncate for example
            text.fontSize = 12;
            frame.appendChild(text);

            // Add more sophisticated parsing and Figma node creation here based on the HTML/CSS
            // This is where you'd use your HTML/CSS parsing and Auto Layout logic.

            figma.notify('Website captured and processed!');

        } catch (error) {
            console.error("Error capturing website:", error);
            figma.ui.postMessage({ type: 'captureError', error: error.message });
        }
    }
};
manifest.json: Crucially, you need to declare network access permissions in your manifest.json file.

JSON

{
  "name": "My Website to Figma Plugin",
  "id": "YOUR_PLUGIN_ID",
  "api": "1.0.0",
  "main": "code.js",
  "ui": "ui.html",
  "networkAccess": {
    "allowedDomains": [
      "https://your-server-domain.com", // Replace with your actual server URL
      "http://localhost:3000" // For local development of your server
    ],
    "reasoning": "To fetch website content from an external server for design conversion."
  },
  "editorType": ["figma"],
  "capabilities": ["codegen"]
}
networkAccess.allowedDomains: This is where you whitelist the domains your plugin is allowed to fetch from. If you don't list your server's domain here, even your server calls will fail with a permission error.

reasoning: Figma requires a clear reason for network access for security review.

2. Your External Server (Backend - Node.js + Puppeteer/Playwright)

This server will be responsible for visiting the requested website, extracting its content, and sending it back to your Figma plugin.

Technology Stack:

Node.js: A popular choice for backend services that interact with JavaScript frontend (your plugin).

Express.js: A minimalist web framework for Node.js, making API creation straightforward.

Puppeteer or Playwright: Headless browser automation libraries. They launch a real (but invisible) browser, allowing you to:

Navigate to URLs.

Wait for pages to fully load, including JavaScript-rendered content.

Execute JavaScript within the page's context (e.g., window.getComputedStyle).

Extract HTML, CSS, and other assets.

Example Server-side (server.js using Node.js/Express/Puppeteer):

JavaScript

const express = require('express');
const puppeteer = require('puppeteer');
const cors = require('cors'); // To allow your Figma plugin to connect

const app = express();
const port = 3000; // Choose any port, but remember to update manifest.json

app.use(cors()); // Enable CORS for all routes (for development, restrict in production)
app.use(express.json()); // To parse JSON request bodies

app.post('/capture', async (req, res) => {
    const { url } = req.body;

    if (!url) {
        return res.status(400).json({ error: 'URL is required' });
    }

    let browser;
    try {
        browser = await puppeteer.launch({
            headless: true, // Run in headless mode (no visible browser UI)
            args: ['--no-sandbox', '--disable-setuid-sandbox'] // Recommended for some environments
        });
        const page = await browser.newPage();

        // Set a user agent to mimic a real browser
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');

        // Navigate to the URL and wait for the page to load
        await page.goto(url, { waitUntil: 'networkidle0', timeout: 60000 }); // Wait for network to be idle, up to 60 seconds

        // Extract HTML and computed styles
        const pageData = await page.evaluate(() => {
            const html = document.documentElement.outerHTML;

            // This part is crucial for getting actual styles.
            // You'll need a more sophisticated way to get *all* relevant styles
            // (e.g., iterating through all elements and getting their getComputedStyle)
            // For a basic example, we'll just return the raw HTML for now.
            // A real implementation would parse CSS rules, apply cascade, and get computed styles for each element.

            // Example of getting computed style for body (for demonstration)
            const bodyComputedStyle = JSON.stringify(window.getComputedStyle(document.body));

            return { html, bodyComputedStyle };
        });

        // You would typically parse the HTML and CSS here on the server
        // and send a more structured data representation back to Figma,
        // rather than raw HTML/CSS strings, as it makes Figma's job easier.
        // e.g., an array of objects, where each object represents a Figma node
        // with its type, content, and style properties.

        res.json({ html: pageData.html, css: pageData.bodyComputedStyle }); // Send back to Figma plugin

    } catch (error) {
        console.error('Error during capture:', error);
        res.status(500).json({ error: `Failed to capture website: ${error.message}` });
    } finally {
        if (browser) {
            await browser.close();
        }
    }
});

app.listen(port, () => {
    console.log(`Server listening at http://localhost:${port}`);
});
npm install express puppeteer cors

CORS Configuration: app.use(cors()); is essential for development to allow your Figma plugin (which will have a null origin or Figma's web app origin) to make requests to your server. In production, you'd want to restrict cors() to only allow Access-Control-Allow-Origin for Figma's domains or your specific plugin's origin.

page.evaluate(): This is where you execute JavaScript within the context of the loaded web page. This allows you to use browser APIs like document.documentElement.outerHTML or window.getComputedStyle().

waitUntil: 'networkidle0': This tells Puppeteer to wait until there are no more than 0 network connections for at least 500ms, which generally indicates the page (and its dynamic content) has finished loading.

Extracting Computed Styles: This is crucial. window.getComputedStyle(element) in page.evaluate() gives you the final, computed styles of an element after all CSS rules, inheritance, and JavaScript manipulations have been applied. You'll need to iterate through all relevant elements on the page and collect their computed styles.

Deployment:

Once your server is built, you'll need to deploy it to a cloud platform so your Figma plugin can access it when not running locally. Options include:

Heroku

Vercel (for serverless functions)

Netlify Functions (for serverless functions)

AWS Lambda/EC2

Google Cloud Run/App Engine

Summary of Workflow:

User enters URL in Figma plugin UI.

ui.js sends URL to code.js.

code.js makes an fetch request to your external server.

Your external server receives the URL.

Your server launches a headless browser (Puppeteer/Playwright).

The headless browser navigates to the URL, waits for rendering.

The headless browser executes JavaScript to extract fully rendered HTML and computed CSS properties for each element.

Your server processes this extracted data (e.g., into a structured JSON format that's easy for Figma).

Your server sends the structured HTML/CSS data back to your Figma plugin's code.js.

code.js receives the data and uses Figma's API (figma.createFrame, figma.createText, layoutMode, etc.) to recreate the design in Figma.

code.js sends status/success messages back to ui.js.

This architecture is the standard way to overcome browser security restrictions and enable powerful web scraping capabilities within a Figma plugin. It's a significant engineering task, but very rewarding!