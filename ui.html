<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Website to Figma</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 260px;
    }
    
    .container {
      max-width: 360px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    
    .header h1 {
      margin: 0 0 8px 0;
      font-size: 24px;
      font-weight: 600;
    }
    
    .header p {
      margin: 0;
      opacity: 0.9;
      font-size: 14px;
    }
    
    .form-group {
      margin-bottom: 16px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      font-size: 14px;
    }
    
    .form-group input {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      backdrop-filter: blur(10px);
      box-sizing: border-box;
    }
    
    .form-group input::placeholder {
      color: rgba(255, 255, 255, 0.7);
    }
    
    .form-group input:focus {
      outline: none;
      background: rgba(255, 255, 255, 0.2);
    }
    
    .btn {
      width: 100%;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 12px;
    }
    
    .btn-primary {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      backdrop-filter: blur(10px);
    }
    
    .btn-primary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .status {
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      text-align: center;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      min-height: 20px;
    }
    
    .status.success {
      background: rgba(76, 175, 80, 0.3);
    }
    
    .status.error {
      background: rgba(244, 67, 54, 0.3);
    }
    
    .status.loading {
      background: rgba(255, 193, 7, 0.3);
    }
    
    .progress {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      overflow: hidden;
      margin: 12px 0;
      display: none;
    }
    
    .progress-fill {
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .capture-area {
      margin-top: 20px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      backdrop-filter: blur(10px);
    }
    
    .capture-area h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 600;
      color: white;
    }
    
    .capture-iframe {
      width: 100%;
      height: 200px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      background: white;
    }
    
    .capture-info {
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      text-align: center;
    }
    
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 14px;
      padding: 8px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      transition: background 0.2s ease;
    }
    
    .checkbox-label:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .checkbox-label input[type="checkbox"] {
      margin: 0;
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üåê Website to Figma</h1>
      <p>Capture and convert any website to Figma</p>
    </div>
    
    <div class="form-group">
      <label for="websiteUrl">Website URL</label>
      <input 
        type="url" 
        id="websiteUrl" 
        placeholder="https://example.com"
        value="https://example.com"
      >
    </div>
    
    <div class="form-group">
      <label>Capture Viewports</label>
      <div class="checkbox-group">
        <label class="checkbox-label">
          <input type="checkbox" id="desktop" checked>
          üñ•Ô∏è Desktop (1440px)
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="tablet" checked>
          üì± Tablet (768px)
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="mobile" checked>
          üì± Mobile (375px)
        </label>
      </div>
    </div>
    
    <button id="captureBtn" class="btn btn-primary">
      üì∑ Capture Responsive Views
    </button>
    
    <div class="progress" id="progressContainer">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    
    <div id="status" class="status">
      Enter a website URL and click capture to start
    </div>
    
    <!-- Capture area with sandbox iframe -->
    <div id="captureArea" class="capture-area" style="display: none;">
      <h3>Capturing Website Content</h3>
      <iframe id="captureFrame" class="capture-iframe" sandbox="allow-scripts allow-same-origin"></iframe>
      <div class="capture-info">
        Website is being analyzed for conversion to Figma...
      </div>
    </div>
  </div>

  <script>
    console.log('UI loaded');
    
    const captureBtn = document.getElementById('captureBtn');
    const urlInput = document.getElementById('websiteUrl');
    const status = document.getElementById('status');
    const progressContainer = document.getElementById('progressContainer');
    const progressFill = document.getElementById('progressFill');
    
    captureBtn.onclick = () => {
      const url = urlInput.value.trim();
      
      if (!url) {
        updateStatus('Please enter a website URL', 'error');
        return;
      }
      
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        updateStatus('Please enter a valid URL (starting with http:// or https://)', 'error');
        return;
      }
      
      // Get selected viewports
      const selectedViewports = [];
      if (document.getElementById('desktop').checked) selectedViewports.push('desktop');
      if (document.getElementById('tablet').checked) selectedViewports.push('tablet');
      if (document.getElementById('mobile').checked) selectedViewports.push('mobile');
      
      if (selectedViewports.length === 0) {
        updateStatus('Please select at least one viewport', 'error');
        return;
      }
      
      // Start capture process using sandbox iframe
      captureBtn.disabled = true;
      updateStatus(`Starting sandbox capture for ${selectedViewports.length} viewports...`, 'loading');
      showProgress(10);
      
      // Use sandbox iframe approach for direct capture
      captureWithSandboxIframe(url, selectedViewports);
    };
    
    // Listen for messages from main plugin code
    window.onmessage = (event) => {
      const { type, success, message, error } = event.data.pluginMessage || {};
      
      if (type === 'captureComplete') {
        captureBtn.disabled = false;
        hideProgress();
        
        if (success) {
          updateStatus(message || 'Website captured successfully!', 'success');
        } else {
          updateStatus(error || 'Capture failed', 'error');
        }
      }
    };
    
    function updateStatus(message, type = 'info') {
      status.textContent = message;
      status.className = `status ${type}`;
    }
    
    function showProgress(percentage) {
      progressContainer.style.display = 'block';
      progressFill.style.width = percentage + '%';
    }
    
    function hideProgress() {
      progressContainer.style.display = 'none';
      progressFill.style.width = '0%';
    }
    
    // Sandbox iframe capture functions
    async function captureWithSandboxIframe(url, viewports) {
      try {
        const captureArea = document.getElementById('captureArea');
        const captureFrame = document.getElementById('captureFrame');
        
        captureArea.style.display = 'block';
        
        const allCapturedData = {
          url: url,
          capture_time: Date.now() / 1000,
          total_viewports: viewports.length,
          viewports: {}
        };
        
        for (let i = 0; i < viewports.length; i++) {
          const viewport = viewports[i];
          const progress = ((i + 1) / viewports.length) * 80 + 10;
          
          showProgress(progress);
          updateStatus(\`Capturing \${viewport} viewport...\`, 'loading');
          
          const viewportConfig = getViewportConfig(viewport);
          captureFrame.style.width = viewportConfig.width + 'px';
          captureFrame.style.height = viewportConfig.height + 'px';
          
          const viewportData = await captureViewportData(captureFrame, url, viewportConfig);
          allCapturedData.viewports[viewport] = viewportData;
          
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        captureArea.style.display = 'none';
        
        showProgress(95);
        updateStatus('Creating Figma layouts...', 'loading');
        parent.postMessage({ 
          pluginMessage: { 
            type: 'sandboxCaptureComplete', 
            data: allCapturedData 
          } 
        }, '*');
        
        setTimeout(() => {
          hideProgress();
          captureBtn.disabled = false;
          updateStatus(\`Sandbox capture complete! Created \${viewports.length} layouts.\`, 'success');
        }, 1000);
        
      } catch (error) {
        console.error('Sandbox capture error:', error);
        updateStatus('Capture failed: ' + error.message, 'error');
        captureBtn.disabled = false;
        document.getElementById('captureArea').style.display = 'none';
        hideProgress();
      }
    }
    
    function captureViewportData(iframe, url, viewportConfig) {
      return new Promise((resolve) => {
        iframe.src = url;
        
        iframe.onload = () => {
          setTimeout(() => {
            try {
              const doc = iframe.contentDocument || iframe.contentWindow.document;
              const win = iframe.contentWindow;
              
              if (!doc || !win) {
                throw new Error('Cannot access iframe content');
              }
              
              const elements = [];
              traverseDOM(doc.body, elements, 0, win);
              
              const capturedData = {
                device: viewportConfig.device,
                viewport: { width: viewportConfig.width, height: viewportConfig.height },
                url: url,
                page: {
                  title: doc.title || 'Untitled',
                  url: url,
                  viewport_width: viewportConfig.width,
                  viewport_height: viewportConfig.height,
                  device_pixel_ratio: win.devicePixelRatio || 1
                },
                elements: elements.slice(0, 20),
                text_styles: extractTextStyles(elements),
                colors: extractColors(elements),
                images: []
              };
              
              resolve(capturedData);
            } catch (error) {
              console.warn('CORS restriction, using mock data:', error);
              resolve(createMockData(url, viewportConfig));
            }
          }, 2000);
        };
        
        iframe.onerror = () => resolve(createMockData(url, viewportConfig));
      });
    }
    
    function traverseDOM(element, elements, depth, win) {
      if (depth > 4 || elements.length > 20) return;
      if (element.nodeType !== Node.ELEMENT_NODE) return;
      
      const rect = element.getBoundingClientRect();
      const computedStyle = win.getComputedStyle(element);
      
      if (rect.width <= 2 || rect.height <= 2 || computedStyle.display === 'none') return;
      
      elements.push({
        tagName: element.tagName,
        className: element.className || '',
        textContent: element.textContent ? element.textContent.trim().substring(0, 50) : '',
        position: { x: Math.round(rect.left), y: Math.round(rect.top), width: Math.round(rect.width), height: Math.round(rect.height) },
        visual: { backgroundColor: computedStyle.backgroundColor, color: computedStyle.color, borderRadius: computedStyle.borderRadius, boxShadow: computedStyle.boxShadow },
        typography: { fontFamily: computedStyle.fontFamily, fontSize: computedStyle.fontSize, fontWeight: computedStyle.fontWeight, lineHeight: computedStyle.lineHeight, textAlign: computedStyle.textAlign, color: computedStyle.color },
        layout_detection: { isTextNode: element.children.length === 0 && element.textContent.trim().length > 0, isFlexContainer: computedStyle.display === 'flex', isGridContainer: computedStyle.display === 'grid' },
        visual_hierarchy: { zIndex: computedStyle.zIndex === 'auto' ? 1 : parseInt(computedStyle.zIndex) || 1, depth: depth }
      });
      
      for (const child of element.children) {
        traverseDOM(child, elements, depth + 1, win);
      }
    }
    
    function extractTextStyles(elements) {
      const styles = new Set();
      elements.forEach(el => {
        if (el.typography) {
          styles.add(JSON.stringify({ fontFamily: el.typography.fontFamily, fontSize: el.typography.fontSize, fontWeight: el.typography.fontWeight, color: el.typography.color }));
        }
      });
      return Array.from(styles).map(s => JSON.parse(s));
    }
    
    function extractColors(elements) {
      const colors = new Set();
      elements.forEach(el => {
        if (el.visual && el.visual.backgroundColor && el.visual.backgroundColor !== 'rgba(0, 0, 0, 0)') colors.add(el.visual.backgroundColor);
        if (el.visual && el.visual.color) colors.add(el.visual.color);
      });
      return Array.from(colors);
    }
    
    function createMockData(url, viewportConfig) {
      return {
        device: viewportConfig.device,
        viewport: { width: viewportConfig.width, height: viewportConfig.height },
        url: url,
        page: { title: \`\${viewportConfig.device} - \${url}\`, url: url, viewport_width: viewportConfig.width, viewport_height: viewportConfig.height, device_pixel_ratio: 1 },
        elements: [
          { tagName: 'DIV', className: 'container', textContent: \`Sandbox capture for \${viewportConfig.device}\`, position: { x: 0, y: 0, width: viewportConfig.width, height: 100 }, visual: { backgroundColor: '#ffffff', color: '#333333', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }, typography: { fontFamily: 'Arial, sans-serif', fontSize: '16px', fontWeight: '400', lineHeight: '1.5', textAlign: 'left', color: '#333333' }, layout_detection: { isTextNode: true, isFlexContainer: false, isGridContainer: false }, visual_hierarchy: { zIndex: 1, depth: 1 } },
          { tagName: 'H1', className: 'title', textContent: \`\${viewportConfig.device} Title\`, position: { x: 20, y: 20, width: viewportConfig.width - 40, height: 40 }, visual: { backgroundColor: 'transparent', color: '#2563eb', borderRadius: '0px' }, typography: { fontFamily: 'Arial, sans-serif', fontSize: '24px', fontWeight: '700', lineHeight: '1.2', textAlign: 'left', color: '#2563eb' }, layout_detection: { isTextNode: true, isFlexContainer: false, isGridContainer: false }, visual_hierarchy: { zIndex: 2, depth: 2 } }
        ],
        text_styles: [{ fontFamily: 'Arial, sans-serif', fontSize: '16px', fontWeight: '400', color: '#333333' }, { fontFamily: 'Arial, sans-serif', fontSize: '24px', fontWeight: '700', color: '#2563eb' }],
        colors: ['#ffffff', '#333333', '#2563eb'],
        images: []
      };
    }
    
    function getViewportConfig(viewport) {
      const configs = { desktop: { width: 1440, height: 900, device: 'Desktop' }, tablet: { width: 768, height: 1024, device: 'Tablet' }, mobile: { width: 375, height: 667, device: 'Mobile' } };
      return configs[viewport] || configs.desktop;
    }
  </script>
</body>
</html>