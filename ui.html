<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Website to Figma</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 260px;
    }
    
    .container {
      max-width: 360px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    
    .header h1 {
      margin: 0 0 8px 0;
      font-size: 24px;
      font-weight: 600;
    }
    
    .header p {
      margin: 0;
      opacity: 0.9;
      font-size: 14px;
    }
    
    .form-group {
      margin-bottom: 16px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      font-size: 14px;
    }
    
    .form-group input {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      backdrop-filter: blur(10px);
      box-sizing: border-box;
    }
    
    .form-group input::placeholder {
      color: rgba(255, 255, 255, 0.7);
    }
    
    .form-group input:focus {
      outline: none;
      background: rgba(255, 255, 255, 0.2);
    }
    
    .btn {
      width: 100%;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 12px;
    }
    
    .btn-primary {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      backdrop-filter: blur(10px);
    }
    
    .btn-primary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .status {
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      text-align: center;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      min-height: 20px;
    }
    
    .status.success {
      background: rgba(76, 175, 80, 0.3);
    }
    
    .status.error {
      background: rgba(244, 67, 54, 0.3);
    }
    
    .status.loading {
      background: rgba(255, 193, 7, 0.3);
    }
    
    .progress {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      overflow: hidden;
      margin: 12px 0;
      display: none;
    }
    
    .progress-fill {
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .capture-area {
      margin-top: 20px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      backdrop-filter: blur(10px);
    }
    
    .capture-area h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 600;
      color: white;
    }
    
    .capture-iframe {
      width: 100%;
      height: 200px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      background: white;
    }
    
    .capture-info {
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      text-align: center;
    }
    
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 14px;
      padding: 8px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      transition: background 0.2s ease;
    }
    
    .checkbox-label:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .checkbox-label input[type="checkbox"] {
      margin: 0;
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üåê Website to Figma</h1>
      <p>Capture and convert any website to Figma</p>
    </div>
    
    <div class="form-group">
      <label for="websiteUrl">Website URL</label>
      <input 
        type="url" 
        id="websiteUrl" 
        placeholder="https://example.com"
        value="https://example.com"
      >
    </div>
    
    <div class="form-group">
      <label>Capture Viewports</label>
      <div class="checkbox-group">
        <label class="checkbox-label">
          <input type="checkbox" id="desktop" checked>
          üñ•Ô∏è Desktop (1440px)
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="tablet" checked>
          üì± Tablet (768px)
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="mobile" checked>
          üì± Mobile (375px)
        </label>
      </div>
    </div>
    
    <button id="captureBtn" class="btn btn-primary">
      üì∑ Capture Responsive Views
    </button>
    
    <div class="progress" id="progressContainer">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    
    <div id="status" class="status">
      Enter a website URL and click capture to start
    </div>
    
    <!-- Capture area with sandbox iframe -->
    <div id="captureArea" class="capture-area" style="display: none;">
      <h3>Capturing Website Content</h3>
      <iframe id="captureFrame" class="capture-iframe" sandbox="allow-scripts allow-same-origin"></iframe>
      <div class="capture-info">
        Website is being analyzed for conversion to Figma...
      </div>
    </div>
  </div>

  <script>
    console.log('UI loaded');
    
    const captureBtn = document.getElementById('captureBtn');
    const urlInput = document.getElementById('websiteUrl');
    const status = document.getElementById('status');
    const progressContainer = document.getElementById('progressContainer');
    const progressFill = document.getElementById('progressFill');
    
    captureBtn.onclick = () => {
      const url = urlInput.value.trim();
      
      if (!url) {
        updateStatus('Please enter a website URL', 'error');
        return;
      }
      
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        updateStatus('Please enter a valid URL (starting with http:// or https://)', 'error');
        return;
      }
      
      // Get selected viewports
      const selectedViewports = [];
      if (document.getElementById('desktop').checked) selectedViewports.push('desktop');
      if (document.getElementById('tablet').checked) selectedViewports.push('tablet');
      if (document.getElementById('mobile').checked) selectedViewports.push('mobile');
      
      if (selectedViewports.length === 0) {
        updateStatus('Please select at least one viewport', 'error');
        return;
      }
      
      // Start capture process - try sandbox first, fallback to server
      captureBtn.disabled = true;
      updateStatus('Starting capture for ' + selectedViewports.length + ' viewports...', 'loading');
      showProgress(10);
      
      // For now, go directly to server capture due to CSP restrictions
      parent.postMessage({ 
        pluginMessage: { 
          type: 'captureResponsive', 
          url: url,
          viewports: selectedViewports
        } 
      }, '*');
    };
    
    // Listen for messages from main plugin code
    window.onmessage = (event) => {
      const { type, success, message, error } = event.data.pluginMessage || {};
      
      if (type === 'captureComplete') {
        captureBtn.disabled = false;
        hideProgress();
        
        if (success) {
          updateStatus(message || 'Website captured successfully!', 'success');
        } else {
          updateStatus(error || 'Capture failed', 'error');
        }
      }
    };
    
    function updateStatus(message, type = 'info') {
      status.textContent = message;
      status.className = `status ${type}`;
    }
    
    function showProgress(percentage) {
      progressContainer.style.display = 'block';
      progressFill.style.width = percentage + '%';
    }
    
    function hideProgress() {
      progressContainer.style.display = 'none';
      progressFill.style.width = '0%';
    }
    
    // Enhanced sandbox iframe capture with comprehensive asset and style extraction
    async function captureWithSandboxIframe(url, viewports) {
      try {
        const captureArea = document.getElementById('captureArea');
        const captureFrame = document.getElementById('captureFrame');
        
        captureArea.style.display = 'block';
        
        const allCapturedData = {
          url: url,
          capture_time: Date.now() / 1000,
          total_viewports: viewports.length,
          viewports: {}
        };
        
        for (let i = 0; i < viewports.length; i++) {
          const viewport = viewports[i];
          const progress = ((i + 1) / viewports.length) * 80 + 10;
          
          showProgress(progress);
          updateStatus('Capturing ' + viewport + ' viewport with assets...', 'loading');
          
          const viewportConfig = getViewportConfig(viewport);
          captureFrame.style.width = viewportConfig.width + 'px';
          captureFrame.style.height = viewportConfig.height + 'px';
          
          const viewportData = await captureViewportDataWithAssets(captureFrame, url, viewportConfig);
          allCapturedData.viewports[viewport] = viewportData;
          
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        captureArea.style.display = 'none';
        
        showProgress(95);
        updateStatus('Creating pixel-perfect Figma layouts...', 'loading');
        parent.postMessage({ 
          pluginMessage: { 
            type: 'sandboxCaptureComplete', 
            data: allCapturedData 
          } 
        }, '*');
        
        setTimeout(() => {
          hideProgress();
          captureBtn.disabled = false;
          updateStatus('Capture complete! Created ' + viewports.length + ' precise layouts with assets.', 'success');
        }, 1000);
        
      } catch (error) {
        console.error('Enhanced capture error:', error);
        updateStatus('Capture failed: ' + error.message, 'error');
        captureBtn.disabled = false;
        document.getElementById('captureArea').style.display = 'none';
        hideProgress();
      }
    }
    
    function captureViewportDataWithAssets(iframe, url, viewportConfig) {
      return new Promise((resolve, reject) => {
        // Check if URL is allowed by CSP
        if (url.includes('example.com') || url.includes('localhost')) {
          console.warn('URL restricted by CSP, using enhanced mock data');
          resolve(createEnhancedMockData(url, viewportConfig));
          return;
        }
        
        iframe.src = url;
        
        const timeout = setTimeout(() => {
          console.warn('Iframe load timeout, using enhanced mock data');
          resolve(createEnhancedMockData(url, viewportConfig));
        }, 5000);
        
        iframe.onload = () => {
          clearTimeout(timeout);
          setTimeout(async () => {
            try {
              const doc = iframe.contentDocument || iframe.contentWindow.document;
              const win = iframe.contentWindow;
              
              if (!doc || !win) {
                throw new Error('Cannot access iframe content');
              }
              
              // Enhanced comprehensive capture
              const captureResult = await performComprehensiveCapture(doc, win, viewportConfig);
              resolve(captureResult);
              
            } catch (error) {
              console.warn('CORS restriction, using enhanced mock data:', error);
              resolve(createEnhancedMockData(url, viewportConfig));
            }
          }, 2000);
        };
        
        iframe.onerror = () => {
          clearTimeout(timeout);
          resolve(createEnhancedMockData(url, viewportConfig));
        };
      });
    }
    
    async function performComprehensiveCapture(doc, win, viewportConfig) {
      const elements = [];
      const assets = [];
      const computedStyles = new Map();
      
      // Calculate scaling for 1440px desktop width
      const actualPageWidth = Math.max(doc.documentElement.scrollWidth, win.innerWidth);
      const desktopWidth = 1440;
      const scale = viewportConfig.device === 'Desktop' ? 1 : (desktopWidth / actualPageWidth);
      
      // Enhanced DOM traversal with asset capture
      await traverseDOMWithAssets(doc.body, elements, assets, computedStyles, 0, win, scale);
      
      // Download and convert assets to base64
      const processedAssets = await downloadAssets(assets, doc);
      
      const pageHeight = Math.max(doc.documentElement.scrollHeight, win.innerHeight);
      
      return {
        device: viewportConfig.device,
        viewport: { 
          width: viewportConfig.device === 'Desktop' ? desktopWidth : viewportConfig.width, 
          height: viewportConfig.height 
        },
        url: doc.location.href,
        page: {
          title: doc.title || 'Untitled',
          url: doc.location.href,
          viewport_width: viewportConfig.device === 'Desktop' ? desktopWidth : viewportConfig.width,
          viewport_height: pageHeight * scale,
          device_pixel_ratio: win.devicePixelRatio || 1,
          actual_width: actualPageWidth,
          scale_factor: scale
        },
        elements: elements,
        assets: processedAssets,
        text_styles: extractEnhancedTextStyles(elements),
        colors: extractEnhancedColors(elements),
        computed_styles: Array.from(computedStyles.entries())
      };
    }
    
    async function traverseDOMWithAssets(element, elements, assets, computedStyles, depth, win, scale) {
      if (depth > 8 || elements.length > 100) return;
      if (element.nodeType !== Node.ELEMENT_NODE) return;
      
      const rect = element.getBoundingClientRect();
      const computedStyle = win.getComputedStyle(element);
      
      if (rect.width <= 1 || rect.height <= 1 || computedStyle.display === 'none') return;
      
      // Capture all computed styles
      const allStyles = {};
      for (let i = 0; i < computedStyle.length; i++) {
        const prop = computedStyle[i];
        allStyles[prop] = computedStyle.getPropertyValue(prop);
      }
      
      // Scale coordinates for 1440px desktop
      const scaledRect = {
        x: Math.round((rect.left + win.scrollX) * scale),
        y: Math.round((rect.top + win.scrollY) * scale),
        width: Math.round(rect.width * scale),
        height: Math.round(rect.height * scale)
      };
      
      const elementData = {
        id: `element_${depth}_${elements.length}`,
        tagName: element.tagName,
        className: element.className || '',
        textContent: getCleanTextContent(element),
        position: scaledRect,
        originalPosition: {
          x: Math.round(rect.left + win.scrollX),
          y: Math.round(rect.top + win.scrollY),
          width: Math.round(rect.width),
          height: Math.round(rect.height)
        },
        computedStyles: allStyles,
        visual: extractVisualProperties(computedStyle, scale),
        typography: extractTypographyProperties(computedStyle, scale),
        layout_detection: analyzeLayoutDetection(element, computedStyle),
        visual_hierarchy: {
          zIndex: computedStyle.zIndex === 'auto' ? depth : parseInt(computedStyle.zIndex) || depth,
          depth: depth,
          hasChildren: element.children.length > 0
        },
        attributes: extractAllAttributes(element)
      };
      
      // Handle images and background images
      if (element.tagName === 'IMG' && element.src) {
        assets.push({
          type: 'image',
          elementId: elementData.id,
          src: element.src,
          alt: element.alt || '',
          naturalWidth: element.naturalWidth,
          naturalHeight: element.naturalHeight
        });
        elementData.hasAsset = true;
        elementData.assetType = 'image';
      }
      
      // Extract background images
      if (computedStyle.backgroundImage && computedStyle.backgroundImage !== 'none') {
        const bgMatch = computedStyle.backgroundImage.match(/url\(["']?([^"')]+)["']?\)/);
        if (bgMatch) {
          assets.push({
            type: 'background-image',
            elementId: elementData.id,
            src: bgMatch[1],
            backgroundSize: computedStyle.backgroundSize,
            backgroundPosition: computedStyle.backgroundPosition,
            backgroundRepeat: computedStyle.backgroundRepeat
          });
          elementData.hasAsset = true;
          elementData.assetType = 'background-image';
        }
      }
      
      elements.push(elementData);
      computedStyles.set(elementData.id, allStyles);
      
      // Process children
      for (const child of element.children) {
        await traverseDOMWithAssets(child, elements, assets, computedStyles, depth + 1, win, scale);
      }
    }
    
    async function downloadAssets(assets, doc) {
      const processedAssets = [];
      
      for (const asset of assets) {
        try {
          // Convert relative URLs to absolute
          const absoluteUrl = new URL(asset.src, doc.location.href).href;
          
          // Create a canvas to capture the image
          const img = new Image();
          img.crossOrigin = 'anonymous';
          
          const base64Data = await new Promise((resolve, reject) => {
            img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = img.naturalWidth || img.width;
              canvas.height = img.naturalHeight || img.height;
              
              try {
                ctx.drawImage(img, 0, 0);
                const dataURL = canvas.toDataURL('image/png', 0.8);
                resolve(dataURL);
              } catch (error) {
                // CORS error, use placeholder
                resolve(createPlaceholderImage(canvas.width, canvas.height));
              }
            };
            
            img.onerror = () => {
              // Create placeholder for failed images
              resolve(createPlaceholderImage(200, 150));
            };
            
            // Timeout for slow loading images
            setTimeout(() => {
              resolve(createPlaceholderImage(200, 150));
            }, 3000);
            
            img.src = absoluteUrl;
          });
          
          processedAssets.push({
            ...asset,
            base64: base64Data,
            absoluteUrl: absoluteUrl,
            width: img.naturalWidth || img.width || 200,
            height: img.naturalHeight || img.height || 150
          });
          
        } catch (error) {
          console.warn('Failed to process asset:', asset.src, error);
          processedAssets.push({
            ...asset,
            base64: createPlaceholderImage(200, 150),
            error: error.message
          });
        }
      }
      
      return processedAssets;
    }
    
    function createPlaceholderImage(width, height) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      
      // Create a gradient placeholder
      const gradient = ctx.createLinearGradient(0, 0, width, height);
      gradient.addColorStop(0, '#f0f0f0');
      gradient.addColorStop(1, '#d0d0d0');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      // Add placeholder text
      ctx.fillStyle = '#888';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Image', width / 2, height / 2);
      
      return canvas.toDataURL('image/png', 0.8);
    }
    
    function traverseDOM(element, elements, depth, win) {
      if (depth > 4 || elements.length > 20) return;
      if (element.nodeType !== Node.ELEMENT_NODE) return;
      
      const rect = element.getBoundingClientRect();
      const computedStyle = win.getComputedStyle(element);
      
      if (rect.width <= 2 || rect.height <= 2 || computedStyle.display === 'none') return;
      
      elements.push({
        tagName: element.tagName,
        className: element.className || '',
        textContent: element.textContent ? element.textContent.trim().substring(0, 50) : '',
        position: { x: Math.round(rect.left), y: Math.round(rect.top), width: Math.round(rect.width), height: Math.round(rect.height) },
        visual: { backgroundColor: computedStyle.backgroundColor, color: computedStyle.color, borderRadius: computedStyle.borderRadius, boxShadow: computedStyle.boxShadow },
        typography: { fontFamily: computedStyle.fontFamily, fontSize: computedStyle.fontSize, fontWeight: computedStyle.fontWeight, lineHeight: computedStyle.lineHeight, textAlign: computedStyle.textAlign, color: computedStyle.color },
        layout_detection: { isTextNode: element.children.length === 0 && element.textContent.trim().length > 0, isFlexContainer: computedStyle.display === 'flex', isGridContainer: computedStyle.display === 'grid' },
        visual_hierarchy: { zIndex: computedStyle.zIndex === 'auto' ? 1 : parseInt(computedStyle.zIndex) || 1, depth: depth }
      });
      
      for (const child of element.children) {
        traverseDOM(child, elements, depth + 1, win);
      }
    }
    
    function extractEnhancedTextStyles(elements) {
      const styles = new Map();
      elements.forEach(el => {
        if (el.typography && el.textContent) {
          const key = `${el.typography.fontFamily}_${el.typography.fontSize}_${el.typography.fontWeight}_${el.typography.color}`;
          if (!styles.has(key)) {
            styles.set(key, {
              ...el.typography,
              usage: 0,
              elements: []
            });
          }
          styles.get(key).usage++;
          styles.get(key).elements.push(el.id);
        }
      });
      return Array.from(styles.entries());
    }
    
    function extractEnhancedColors(elements) {
      const colors = new Map();
      elements.forEach(el => {
        if (el.visual) {
          if (el.visual.backgroundColor && el.visual.backgroundColor !== 'rgba(0, 0, 0, 0)') {
            const key = el.visual.backgroundColor;
            if (!colors.has(key)) colors.set(key, { value: key, usage: 0, type: 'background' });
            colors.get(key).usage++;
          }
          if (el.visual.color && el.visual.color !== 'rgba(0, 0, 0, 0)') {
            const key = el.visual.color;
            if (!colors.has(key)) colors.set(key, { value: key, usage: 0, type: 'text' });
            colors.get(key).usage++;
          }
          if (el.visual.borderColor && el.visual.borderColor !== 'rgba(0, 0, 0, 0)') {
            const key = el.visual.borderColor;
            if (!colors.has(key)) colors.set(key, { value: key, usage: 0, type: 'border' });
            colors.get(key).usage++;
          }
        }
      });
      return Array.from(colors.entries());
    }
    
    function getCleanTextContent(element) {
      let text = '';
      for (const node of element.childNodes) {
        if (node.nodeType === Node.TEXT_NODE) {
          text += node.textContent;
        }
      }
      return text.trim();
    }
    
    function extractVisualProperties(computedStyle, scale) {
      return {
        backgroundColor: computedStyle.backgroundColor,
        color: computedStyle.color,
        borderColor: computedStyle.borderColor,
        borderWidth: parseFloat(computedStyle.borderWidth) * scale || 0,
        borderStyle: computedStyle.borderStyle,
        borderRadius: parseFloat(computedStyle.borderRadius) * scale || 0,
        boxShadow: computedStyle.boxShadow,
        opacity: parseFloat(computedStyle.opacity) || 1,
        transform: computedStyle.transform,
        filter: computedStyle.filter,
        backgroundImage: computedStyle.backgroundImage,
        backgroundSize: computedStyle.backgroundSize,
        backgroundPosition: computedStyle.backgroundPosition,
        backgroundRepeat: computedStyle.backgroundRepeat
      };
    }
    
    function extractTypographyProperties(computedStyle, scale) {
      return {
        fontFamily: computedStyle.fontFamily,
        fontSize: parseFloat(computedStyle.fontSize) * scale || 16,
        fontWeight: computedStyle.fontWeight,
        fontStyle: computedStyle.fontStyle,
        lineHeight: computedStyle.lineHeight,
        textAlign: computedStyle.textAlign,
        textDecoration: computedStyle.textDecoration,
        textTransform: computedStyle.textTransform,
        letterSpacing: parseFloat(computedStyle.letterSpacing) * scale || 0,
        wordSpacing: parseFloat(computedStyle.wordSpacing) * scale || 0,
        color: computedStyle.color
      };
    }
    
    function analyzeLayoutDetection(element, computedStyle) {
      return {
        isTextNode: element.children.length === 0 && element.textContent.trim().length > 0,
        isFlexContainer: computedStyle.display === 'flex',
        isGridContainer: computedStyle.display === 'grid',
        isPositioned: computedStyle.position !== 'static',
        hasTransform: computedStyle.transform !== 'none',
        isInteractive: ['A', 'BUTTON', 'INPUT', 'TEXTAREA', 'SELECT'].includes(element.tagName),
        flexDirection: computedStyle.flexDirection,
        justifyContent: computedStyle.justifyContent,
        alignItems: computedStyle.alignItems,
        gap: computedStyle.gap
      };
    }
    
    function extractAllAttributes(element) {
      const attrs = {};
      for (const attr of element.attributes) {
        attrs[attr.name] = attr.value;
      }
      return attrs;
    }
    
    function createEnhancedMockData(url, viewportConfig) {
      const desktopWidth = 1440;
      const scale = viewportConfig.device === 'Desktop' ? 1 : (desktopWidth / viewportConfig.width);
      const scaledWidth = viewportConfig.device === 'Desktop' ? desktopWidth : viewportConfig.width;
      
      // Create a comprehensive mock with assets
      const mockAssets = [
        {
          type: 'image',
          elementId: 'element_2_3',
          src: 'https://via.placeholder.com/300x200/007acc/ffffff?text=Sample+Image',
          base64: createPlaceholderImage(300, 200),
          width: 300 * scale,
          height: 200 * scale
        }
      ];
      
      return {
        device: viewportConfig.device,
        viewport: { width: scaledWidth, height: viewportConfig.height },
        url: url,
        page: { 
          title: `Enhanced ${viewportConfig.device} - ${url}`, 
          url: url, 
          viewport_width: scaledWidth, 
          viewport_height: viewportConfig.height,
          device_pixel_ratio: 1,
          actual_width: viewportConfig.width,
          scale_factor: scale
        },
        elements: [
          {
            id: 'element_0_0',
            tagName: 'DIV',
            className: 'container',
            textContent: '',
            position: { x: 0, y: 0, width: scaledWidth, height: 100 * scale },
            originalPosition: { x: 0, y: 0, width: viewportConfig.width, height: 100 },
            computedStyles: {
              backgroundColor: '#ffffff',
              padding: '20px',
              borderRadius: '8px',
              boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
              display: 'flex',
              flexDirection: 'column',
              gap: '16px'
            },
            visual: { 
              backgroundColor: '#ffffff', 
              borderRadius: 8 * scale, 
              boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
              opacity: 1
            },
            layout_detection: { 
              isFlexContainer: true, 
              flexDirection: 'column',
              gap: '16px',
              hasChildren: true
            },
            visual_hierarchy: { zIndex: 1, depth: 0, hasChildren: true }
          },
          {
            id: 'element_1_1',
            tagName: 'H1',
            className: 'title',
            textContent: `Enhanced ${viewportConfig.device} Layout (${scaledWidth}px)`,
            position: { x: 20 * scale, y: 20 * scale, width: (scaledWidth - 40), height: 40 * scale },
            originalPosition: { x: 20, y: 20, width: viewportConfig.width - 40, height: 40 },
            computedStyles: {
              fontSize: `${32 * scale}px`,
              fontWeight: '700',
              color: '#2563eb',
              lineHeight: '1.2',
              margin: '0',
              textAlign: 'left'
            },
            visual: { 
              backgroundColor: 'transparent', 
              color: '#2563eb' 
            },
            typography: { 
              fontFamily: 'Arial, sans-serif', 
              fontSize: 32 * scale, 
              fontWeight: '700', 
              color: '#2563eb',
              lineHeight: '1.2',
              textAlign: 'left'
            },
            layout_detection: { isTextNode: true },
            visual_hierarchy: { zIndex: 2, depth: 1 }
          },
          {
            id: 'element_2_2', 
            tagName: 'P',
            className: 'description',
            textContent: 'This is a pixel-perfect recreation with comprehensive asset capture and precise styling.',
            position: { x: 20 * scale, y: 80 * scale, width: (scaledWidth - 40), height: 60 * scale },
            originalPosition: { x: 20, y: 80, width: viewportConfig.width - 40, height: 60 },
            computedStyles: {
              fontSize: `${16 * scale}px`,
              fontWeight: '400',
              color: '#333333',
              lineHeight: '1.5'
            },
            typography: { 
              fontFamily: 'Arial, sans-serif', 
              fontSize: 16 * scale, 
              fontWeight: '400', 
              color: '#333333',
              lineHeight: '1.5'
            },
            layout_detection: { isTextNode: true },
            visual_hierarchy: { zIndex: 1, depth: 1 }
          },
          {
            id: 'element_2_3',
            tagName: 'IMG',
            className: 'sample-image',
            textContent: '',
            position: { x: 20 * scale, y: 160 * scale, width: 300 * scale, height: 200 * scale },
            originalPosition: { x: 20, y: 160, width: 300, height: 200 },
            hasAsset: true,
            assetType: 'image',
            computedStyles: {
              borderRadius: `${8 * scale}px`,
              objectFit: 'cover'
            },
            visual: { 
              borderRadius: 8 * scale 
            },
            layout_detection: { isImageElement: true },
            visual_hierarchy: { zIndex: 1, depth: 1 },
            attributes: {
              src: 'https://via.placeholder.com/300x200/007acc/ffffff?text=Sample+Image',
              alt: 'Sample placeholder image'
            }
          }
        ],
        assets: mockAssets,
        text_styles: [
          ['heading_style', { fontFamily: 'Arial, sans-serif', fontSize: 32 * scale, fontWeight: '700', color: '#2563eb', usage: 1 }],
          ['body_style', { fontFamily: 'Arial, sans-serif', fontSize: 16 * scale, fontWeight: '400', color: '#333333', usage: 1 }]
        ],
        colors: [
          ['#ffffff', { value: '#ffffff', usage: 1, type: 'background' }],
          ['#333333', { value: '#333333', usage: 1, type: 'text' }],
          ['#2563eb', { value: '#2563eb', usage: 1, type: 'text' }]
        ]
      };
    }
    
    function getViewportConfig(viewport) {
      const configs = { desktop: { width: 1440, height: 900, device: 'Desktop' }, tablet: { width: 768, height: 1024, device: 'Tablet' }, mobile: { width: 375, height: 667, device: 'Mobile' } };
      return configs[viewport] || configs.desktop;
    }
  </script>
</body>
</html>